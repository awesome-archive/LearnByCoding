#指定worker的用户/用户组,如果没有指定组，那么将使用与用户名相同的组，默认情况下会使用nobody用户与nobody组（或者nogroup），使用nobody更安全.或者在编译时指定的--user=USER和--group=GROUP的值。
user  qfpay;
#指定了nginx要开启的worker进程数。每个nginx进程平均消耗10MB-12MB内存，根据经验，一般指定一个进程足够了，如果是多核CPU，建议指定和CPU的数量一样多的进程数即可。一个cpu配置多于一个worker数，对nginx而言没有任何益处。如果nginx处理的是cpu密集型（比较耗费cpu的）的操作，比如gzip,ssl等,建议将此值设置为cpu的逻辑个数.一般来说，拥有几个逻辑CPU，就设置为几个worker_processes 为宜，但是 worker_processes 超过8个就没有多大意义了，原因再上面那段英文里已经提到了。
worker_processes  8;
#把woker进程绑定到指定的CPU,默认不绑定任何CPU,一般一个woker绑定一个CPU,0代表开启,1代表关闭.
worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;

events {
	#设定连接处理方式,默认nginx会选择最高效的处理方式,也可以用这种方式来手工指定,epoll 是efficient method used on Linux 2.6+.
    use epoll;
#设定一个woker进程能处理的最大同时连接数,includes all connections (e.g. connections with proxied servers, among others), not only connections with clients.Another consideration is that the actual number of simultaneous connections cannot exceed the current limit on the maximum number of open files, which can be changed by worker_rlimit_nofile.
    worker_connections  65535;
}
#设置单个woker最大打开的文件数.
worker_rlimit_nofile 65535;


http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr $remote_user [$time_local] "$request" '
        '$status $request_length $body_bytes_sent/$bytes_sent "$http_referer" '
        '"$http_user_agent" "$http_x_forwarded_for" $connection $request_time $upstream_response_time';

    log_format  qflog  '$time_iso8601 $remote_addr $remote_user $connection "$request" $request_length '
        '$status $body_bytes_sent $bytes_sent '
        '"$http_referer" "$http_x_forwarded_for" "$http_user_agent" $request_time $upstream_response_time';

    log_format  mmwdlog  '$time_iso8601 $remote_addr $remote_user $connection "$cookie_openid" "$request" $request_length '
        '$status $body_bytes_sent $bytes_sent '
        '"$http_referer" "$http_x_forwarded_for" "$http_user_agent" $request_time $upstream_response_time';

    access_log  logs/access.log  main;

    sendfile        on;
    tcp_nopush      on;

    keepalive_timeout  300;
    gzip  on;
    gzip_types text/plain application/x-javascript text/css text/javascript;

    server_tokens off;

    server_names_hash_bucket_size 128;
    client_header_buffer_size 32k;
    client_max_body_size 20m;
    client_header_timeout 60s;
    client_body_timeout 60s;
     send_timeout 60s;

    fastcgi_connect_timeout 50s;	
    fastcgi_send_timeout 50s;
    fastcgi_read_timeout 50s;



